function dynamic_plots_cdata(data, auto_run, filename)
% Show an animated graph of the vehicle during an autonomous run using data
% recorded by a datalogger.
%   Usage: dynamic_plots(data, RUN_NUMBER, SAVE_TO_VIDEO)
%   data (struct) - A struct generated by ProcessCsvData()
%   auto_run (int) - The autonomous run number. Look this up by running
%   `static_plots` on your data and looking at the title of the plots.
%   filename (string) - If this is not empty, it specifies a filename for
%   recording a video to

    %% Set parameters
    % Set the scaling. Some things don't visualize well at their base
    % units, so scale them a bit.
    boat_scaling = 2;
    velocity_scaling = 2;
    
    % Set the simulation step size. Skip this-1 samples between renders.
    step_size = 10;

    %% Determine periods of autonomous control
    % Check for both autonomous mode from HEARTBEAT @ 10Hz
    valid_autodata_data = ~isnan(data.HEARTBEAT.base_mode);
    auto_mode = bitand(data.HEARTBEAT.base_mode(valid_autodata_data), 4) ~= 0;
    mode_time = data.timestamp(valid_autodata_data);
    [mode_time, i] = unique(mode_time);
    auto_mode = auto_mode(i);

    %% Gather necessary data
    % Get the position and velocity data
    valid_cdata = ~isnan(data.CONTROLLER_DATA.reset);
    cdata_time = data.timestamp(valid_cdata);
    assert(any(valid_cdata), 'No valid CONTROLLER_DATA messages.');
    north = data.CONTROLLER_DATA.north(valid_cdata) / 1e3;
    east = data.CONTROLLER_DATA.east(valid_cdata) / 1e3;
    vel_n = data.CONTROLLER_DATA.north_speed(valid_cdata) / 1e3;
    vel_e = data.CONTROLLER_DATA.east_speed(valid_cdata) / 1e3;

    % Then grab waypoint and desired path data
    from_wp_n = data.CONTROLLER_DATA.last_wp_north(valid_cdata) / 10;
    from_wp_e = data.CONTROLLER_DATA.last_wp_east(valid_cdata) / 10;
    to_wp_n = data.CONTROLLER_DATA.next_wp_north(valid_cdata) / 10;
    to_wp_e = data.CONTROLLER_DATA.next_wp_east(valid_cdata) / 10;
    wps = [from_wp_n from_wp_e to_wp_n to_wp_e];
    
    % And rudder position data
    rudder_angle = data.CONTROLLER_DATA.rudder_angle(valid_cdata) / 1e4;
    commanded_rudder_angle = data.CONTROLLER_DATA.commanded_rudder_angle(valid_cdata) / 1e4;
    
    % The aim point. We also approximate the L2+ vector by using the
    % position from the boat to the aim point as the L2+ vector.
    aim_point_n = data.CONTROLLER_DATA.aim_point_n(valid_cdata) / 10;
    l2_north = aim_point_n - north;
    aim_point_e = data.CONTROLLER_DATA.aim_point_e(valid_cdata) / 10;
    l2_east = aim_point_e - east;

    % And true heading
    heading = data.CONTROLLER_DATA.yaw(valid_cdata) / 2^13;

    % And finally course-over-ground data
    cog = data.CONTROLLER_DATA.cog(valid_cdata) / 1e4;

    % And water velocity (m/s) from DST800 @ 2Hz for the primary node.
    water_speed = data.CONTROLLER_DATA.water_speed(valid_cdata) / 1e4;
    water_vel_e = water_speed .* cos(heading);
    water_vel_n = water_speed .* sin(heading);
    
    %% Separate the above data into the different autonomous runs

    % Interpolate the autonomous mode into the position timeslots
    % 'nearest' mode is used to make sure these values stay logical.
    mode_with_cdata = interp1(mode_time, auto_mode, cdata_time, 'nearest');
    mode_with_cdata(isnan(mode_with_cdata)) = 0;
    mode_with_cdata = logical(mode_with_cdata);
    figure;plot(mode_with_cdata)

    % Split this data into groups based on the mode of autonomousity.
    start_indices = find(diff(mode_with_cdata) > 0);
    % Make sure that if the nearest-neighbor interpolation selects a
    % timestep where the vehicle was under manual control, correct for it.
    while mode_with_cdata(start_indices(1)) == 0
        start_indices(1) = start_indices(1) + 1;
    end
    end_indices = find(diff(mode_with_cdata) < 0);
    assert(length(start_indices) == length(end_indices));
    
    % Select the proper range to animate
    valid_range = start_indices(auto_run):end_indices(auto_run);

    % Output the different run indices. These are all in reference to the
    % timestamps for the CONTROLLER_DATA messages.
    %segments = [start_indices end_indices];
    
    %% Calculate some performance characteristics

    % Also calculate the crosstrack error.
    % This is done via simple vector projection using the vector from the start
    % waypoint to the boat position and the vector from the start waypoint to
    % the next waypoint.
    all_wp_to_boat = [north - wps(:,1) east - wps(:,2)];
    all_wp_to_wp = wps(:,3:4) - wps(:,1:2);
    all_wp_to_wp_norm = sqrt(sum(all_wp_to_wp.^2,2));
    all_wp_to_wp_unit = [all_wp_to_wp(:,1) ./ all_wp_to_wp_norm all_wp_to_wp(:,2) ./ all_wp_to_wp_norm];
    scaling_factor = dot(all_wp_to_boat, all_wp_to_wp,2) ./ all_wp_to_wp_norm;
    all_alongtrack = [all_wp_to_wp_unit(:,1) .* scaling_factor all_wp_to_wp_unit(:,2) .* scaling_factor];
    crosstrack_vector = all_wp_to_boat - all_alongtrack;
    crosstrack_error = sqrt(sum(crosstrack_vector.^2,2));
    clear all_wp_to_boat all_wp_to_wp all_wp_to_wp_norm all_wp_to_wp_unit scaling_factor all_alongtrack;

    % Calculate the course-over-ground error.
    all_wp_to_wp = wps(:,3:4) - wps(:,1:2);
    desired_course = atan2_to_norm_angle(atan2(all_wp_to_wp(:,1), all_wp_to_wp(:,2)));
    course_error = wrapTo180(180/pi*(desired_course - cog));

    %% Animate (use static_plots to determine run to use)

    % Prepare for saving video
    if ~isempty(filename)
        aviWriter = VideoWriter(filename);
        aviWriter.FrameRate = 30;
        open(aviWriter);
    end
    
    % Get the coordinates for icons for the boat and rudder
    [boat_coords, rudder_coords] = icon_coords(boat_scaling);

    % Set whether the animation is playing or not. Setting this to true
    % pauses the rendering loop.
    isPaused = false;

    % If a video is requested, fullscreen the video. Resizing the video
    % mid-playback during recording doesn't work, so this is the only way
    % to get big videos out. This must be done in the first figure() call
    % and not in a separate get() call.
    if ~isempty(filename)
        f = figure('WindowKeyPressFcn', @playpause, 'units', 'normalized', 'outerposition', [0 0 1 1]);
    else
        f = figure('WindowKeyPressFcn', @playpause);
    end

    % Finally plot everything for the first timepoint
    positionAxis = subplot(3,2,[1 3 5]);
    axis(positionAxis, 'equal');
    hold(positionAxis, 'on');
    rudderAxis = subplot(3,2,2);
    hold(rudderAxis, 'on');
    title(rudderAxis, 'Rudder');
    crosstrackErrorAxis = subplot(3,2,4);
    hold(crosstrackErrorAxis, 'on');
    set(crosstrackErrorAxis, 'xticklabel', []);
    title(crosstrackErrorAxis, 'Crosstrack Error (m)');
    headingErrorAxis = subplot(3,2,6);
    hold(headingErrorAxis, 'on');
    set(headingErrorAxis, 'xticklabel', []);
    title(headingErrorAxis, 'Course error');

    % Keep the positionAxis current, necessary for patch()
    axes(positionAxis);

    % Plot the boat position as a dot trail
    boat_pos = plot(positionAxis, east(valid_range(1)), north(valid_range(1)), '.', 'MarkerSize', 15);

    % First calculate the position of the boat at all points during this range
    boat_rotmat = rotmat2(-heading(valid_range(1)));
    boat_coords_rot = boat_coords;
    for i = 1:length(boat_coords_rot)
        boat_coords_rot(i,:) = boat_rotmat*boat_coords_rot(i,:)';
    end
    boat_rotmat = rotmat2(-heading(valid_range(1)));

    % And plot the rudder angle
    rudder_rotmat = rotmat2(-rudder_angle(valid_range(1)));
    rudder_coords_rot = rudder_coords;
    for i = 1:length(rudder_coords_rot)
        rudder_coords_rot(i,:) = boat_rotmat*rudder_rotmat*rudder_coords_rot(i,:)';
    end
    rudder = patch(east(valid_range(1)) + boat_coords_rot(8,1) + rudder_coords_rot(:,1), north(valid_range(1)) + boat_coords_rot(8,2) + rudder_coords_rot(:,2), 'y');

    % And the boat itself (done after the rudder to get ordering right)
    boat = patch(east(valid_range(1)) + boat_coords_rot(:,1), north(valid_range(1)) + boat_coords_rot(:,2), 'y');

    % And its current ground velocity
    velocity = quiver(positionAxis, east(valid_range(1)), north(valid_range(1)), vel_e(valid_range(1)), vel_n(valid_range(1)), 'r');

    % And its water velocity
    water_velocity = quiver(positionAxis, east(valid_range(1)), north(valid_range(1)), water_vel_e(valid_range(1)), water_vel_n(valid_range(1)), 'g');

    % And the current L2+ vector
    l2_vector = quiver(positionAxis, east(valid_range(1)), north(valid_range(1)), l2_north(valid_range(1)), l2_east(valid_range(1)), 'c');

    % And then plot the current waypoint pairing
    wps_n = wps(valid_range, 1:2:3);
    wps_e = wps(valid_range, 2:2:4);
    path = plot(positionAxis, wps_e(1,:), wps_n(1,:), '.--k');

    % On the rudder plot, plot the commanded and real rudder angle
    r_angle = plot(rudderAxis, cdata_time(valid_range(1)), 180/pi*rudder_angle(valid_range(1)), 'k-');
    c_r_angle = plot(rudderAxis, cdata_time(valid_range(1)), 180/pi*commanded_rudder_angle(valid_range(1)), '--b');
    set(rudderAxis, 'YLim', [-45 45]);
    set(rudderAxis, 'YTick', -45:15:45);
    set(rudderAxis, 'YGrid', 'on');

    % On the crosstrack error plot, plot the crosstrack error
    ce = plot(crosstrackErrorAxis, cdata_time(valid_range(1)), crosstrack_error(valid_range(1)), 'k-');
    ce2 = quiver(positionAxis, east(valid_range(1)), north(valid_range(1)), -crosstrack_vector(valid_range(1),2), -crosstrack_vector(valid_range(1),1));
    set(crosstrackErrorAxis, 'YLim', [0 25]);

    % On the heading error plot, plot the heading error
    he = plot(headingErrorAxis, cdata_time(valid_range(1)), course_error(valid_range(1)), 'k-');
    set(headingErrorAxis, 'YLim', [-90 90]);
    set(headingErrorAxis, 'YTick', -90:30:90);
    set(headingErrorAxis, 'YGrid', 'on');
    
    % Save this frame to our video.
    if ~isempty(filename)
        currentFrame = getframe(f);
        writeVideo(aviWriter, currentFrame);
    end

    % And now animate this plot by updating the data for every plot element.
    for i=2:step_size:length(valid_range)
        % If the user closes the window quit animating.
        if ~ishandle(f)
            return;
        end

        % Wait if the animation is paused
        while isPaused
            if ~ishandle(f)
                return;
            end
            pause(0.1)
        end

        % Update the boat position
        set(boat_pos, 'XData', east(valid_range(1:i)), 'YData', north(valid_range(1:i)));

        % Update the boat drawing
        boat_rotmat = rotmat2(-heading(valid_range(i)));
        boat_coords_rot = boat_coords;
        for j = 1:length(boat_coords_rot)
            boat_coords_rot(j,:) = boat_rotmat*boat_coords_rot(j,:)';
        end
        set(boat, 'XData', east(valid_range(i)) + boat_coords_rot(:,1), 'YData', north(valid_range(i)) + boat_coords_rot(:,2));

        % Update the rudder drawing
        rudder_rotmat = rotmat2(-rudder_angle(valid_range(i)));
        rudder_coords_rot = rudder_coords;
        for j = 1:length(rudder_coords_rot)
            rudder_coords_rot(j,:) = boat_rotmat*rudder_rotmat*rudder_coords_rot(j,:)';
        end
        set(rudder, 'XData', east(valid_range(i)) + boat_coords_rot(8,1) + rudder_coords_rot(:,1), 'YData', north(valid_range(i)) + boat_coords_rot(8,2) + rudder_coords_rot(:,2));
        % Update the viewport, keep it centered around the vessel with 60m
        % total viewing space.
        set(positionAxis, 'XLim', [east(valid_range(i)) - 30; east(valid_range(i)) + 30], 'YLim', [north(valid_range(i)) - 30; north(valid_range(i)) + 30]);

        % Update the boat's velocity vector
        set(velocity, 'XData', east(valid_range(i)), 'YData', north(valid_range(i)), 'UData', vel_e(valid_range(i)) * velocity_scaling, 'VData', vel_n(valid_range(i)) * velocity_scaling);

        % Update the boat's water velocity vector
        set(water_velocity, 'XData', east(valid_range(i)), 'YData', north(valid_range(i)), 'UData', water_vel_n(valid_range(i)) * velocity_scaling, 'VData', water_vel_e(valid_range(i)) * velocity_scaling);

        % Update the L2+ vector
        set(l2_vector, 'XData', east(valid_range(i)), 'YData', north(valid_range(i)), 'UData', l2_east(valid_range(i)), 'VData', l2_north(valid_range(i)));

        set(ce2, 'XData', east(valid_range(i)), 'YData', north(valid_range(i)), 'UData', -crosstrack_vector(valid_range(i),2), 'VData', -crosstrack_vector(valid_range(i),1));

        % Update the waypoint track as needed
        set(path, 'XData', wps_e(i,:), 'YData', wps_n(i,:));

        % Update the plot title
        title(positionAxis, sprintf('Autonomous run %d, %.0f seconds\ngreen=v_{water},red=v_{ground},blue=err_{ct},cyan=L1\\_vector', auto_run, cdata_time(valid_range(i)) - cdata_time(valid_range(1))));

        % Update the rudder data
        set(r_angle, 'XData', cdata_time(valid_range(1:i)), 'YData', 180/pi*rudder_angle(valid_range(1:i)));
        set(c_r_angle, 'XData', cdata_time(valid_range(1:i)), 'YData', 180/pi*commanded_rudder_angle(valid_range(1:i)));

        % Update the crosstrack error
        set(ce, 'XData', cdata_time(valid_range(1:i)), 'YData', crosstrack_error(valid_range(1:i)));

        % Update the heading error
        set(he, 'XData', cdata_time(valid_range(1:i)), 'YData', course_error(valid_range(1:i)));

        % And limit the data views to the last 10s of data
        set(rudderAxis, 'XLim', [cdata_time(valid_range(i)) - 10; cdata_time(valid_range(i))]);
        set(crosstrackErrorAxis, 'XLim', [cdata_time(valid_range(i)) - 10; cdata_time(valid_range(i))]);
        set(headingErrorAxis, 'XLim', [cdata_time(valid_range(i)) - 10; cdata_time(valid_range(i))]);
    
        % Save this frame to our video.
        if ~isempty(filename)
            currentFrame = getframe(f);
            writeVideo(aviWriter, currentFrame);

        % Pause until the next frame
        else
            if i < length(valid_range)
                pause(.001);
            end
        end
    end

    % Play/pause the animation when pressing the spacebar
    function playpause(h, e)
        if strcmp(e.Key, 'space')
            isPaused = ~isPaused;
        end
    end
end